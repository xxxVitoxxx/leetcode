# Solution

給 koko n 串香蕉，為長度 n 的整數陣列 piles ，假設每小時吃 x 根香蕉，吃完一個擁有 y 根香蕉的香蕉串需要花的時間為 $\frac{y}{x}$ 四捨五入，如果他每小時吃 3 根香蕉，那麼他需要花 2 小時才能吃完一堆有 4 根香蕉的香蕉串，我們稱每小時吃 3 根香蕉的速度為可行的進食速度。  

**Constraints**
1. koko 必須在 h 小時內吃掉所有香蕉串， h 不會低於香蕉串的數量。  
2. 假設每小時可以吃 k 個香蕉，如果在還沒吃到 k 個前，該香蕉串已經吃完了，則該次不能再吃別串香蕉。  
3. 希望盡可能吃得慢一點，因此在所有可行的進食速度中，我們要找出最小的可行速度。  

## Binary search

我們觀察兩個情況
1. 如果 koko 可以以 n 的速度吃完所有香蕉堆，那肯定也能以 n+1 的速度吃完，當進食速度越大時， koko 會在每堆香蕉上花費相同或更少時間，因此總花費時間將會小於會等於速度 n 花費的時間。  
2. 如果 koko 無法以 n 的速度吃完所有香蕉堆，那肯定也無法以 n-1 的速度吃完，當進食速度越小時， koko 會在每堆香蕉上花費相同或更多時間，總花費時間將會大於或等於速度 n 花費的時間。  

如果當前的進食速度是可行的，則最小可行的進食速度會在左側（包含本身），如果當前進食速度是不可行的，會因為太慢而無法完成，則最小可行的進食速度會在其右側。  

因此我們可以用二分搜尋來定位可行速度與不可行速度的邊界，從而得到最小可行速度。  

首先我們要先定義一個合理的下限與上限以確保我們不會錯過任何可行的速度，我們定義下限為 1 ，即最小的可進食速度。上限是最大的進食速度，也就是擁有最多香蕉的香蕉堆，假設 piles 為 [3, 6, 7, 11] ，則香蕉堆中擁有最多香蕉的數量為 11 ，我們就將上限定義為 11 。  

當我們定義出上下限後，就可以用二分搜尋來縮小搜尋範圍，在每次迭代中，會將剩餘的搜尋範圍減少一半，直到搜索範圍只剩一個元素，該元素就是最小的可行速度。  
