# Solution

## missingNumber4

因要找到 0 ~ n(nums 長度)缺失的數，而 nums 的 index 一定是 0 ~ n-1 ，而 nums 中的數一定是 0 ~ n 之間，而缺失的數只會有一個，所以當 index 與 nums 中的某數是一樣的代表該數不是缺失的數，無須理會（視為 0），而這個情況可以用 `XOR` 判斷（5 ^ 5 = 0）。  

因 index 只會有 0 ~ n-1 ，所以一開始可以先假設缺失的數為 n ，這邊將缺失的數定簡稱為 missing ，依序檢查 missing 與 `index 與 nums[index] 的互斥結果` 的互斥結果，就可以找出缺失的數。  

### Dry Run

以 `[3, 0, 2]` 為例，要找出 0 ~ 3 之間缺失的數。  
先假設缺失的數為 n（3） 並依序檢查 index 與數組中的數字互斥的結果。  
```
循環1
missing = 3

 0000 0000 (index 0)
^0000 0011 (nums[0] => 3)
--------------------
 0000 0011 (3)

 0000 0011 (missing)
^0000 0011 (index 與數字的互斥結果)
--------------------
 0000 0000 (新的 missing)

循環2
missing = 0

 0000 0001 (index 1)
^0000 0000 (nums[1] => 0)
---------------------
 0000 0001 (1)

 0000 0000 (missing)
^0000 0001 (index 與數字的互斥結果)
--------------------
 0000 0001 (新的 missing)

循環3
missing = 1

 0000 0010 (index 2)
^0000 0010 (nums[2])
---------------------
 0000 0000 (0)

 0000 0001 (missing)
^0000 0000 (index 與數字的互斥結果)
--------------------
 0000 0001 (新的 missing)

最終可以找出缺失的數為 1
```
